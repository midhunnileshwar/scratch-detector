import streamlit as st
import zipfile
import json
import hashlib
import difflib
import io
import os
import cv2
import numpy as np
from itertools import combinations
import re

# --- 1. CONFIG & STYLE ---
st.set_page_config(page_title="KITE Forensics Master", page_icon="üõ°Ô∏è", layout="wide")

if 'log_history' not in st.session_state: st.session_state.log_history = []

st.markdown("""
    <style>
    .report-card {background: white; padding: 15px; border-radius: 10px; border-left: 5px solid #c0392b; margin-bottom: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);}
    .student-name {color: #2980b9; font-weight: bold; font-size: 1.1em;}
    .file-path {font-size: 0.8em; color: #7f8c8d; font-family: monospace;}
    .success-box {padding: 15px; background: #d4edda; color: #155724; border-radius: 5px;}
    </style>
""", unsafe_allow_html=True)

# --- 2. INTELLIGENT NAME EXTRACTOR ---
def clean_student_name(full_path, strategy="Auto"):
    """
    Extracts the most likely Student Name from a messy file path.
    Input: "Individual assignment25-26_2/Midhun/Game.sb3"
    Output: "Midhun"
    """
    # Normalize path
    parts = full_path.replace("\\", "/").split("/")
    # Remove empty or system parts
    parts = [p for p in parts if p not in [".", "__MACOSX"] and p.strip() != ""]
    
    filename = parts[-1]
    
    # STRATEGY 1: USER FORCED FILENAME
    if strategy == "File Name Only":
        return os.path.splitext(filename)[0]

    # STRATEGY 2: AUTO-DETECT (The Smart Logic)
    # We look for the folder that is NOT a generic assignment name
    candidate_name = ""
    
    # Generic words generated by LMS/Classroom
    blacklist = ["assignment", "submission", "individual", "project", "activity", "scratch", "game", "untitled", "class"]
    
    # Walk backwards from folder to root
    if len(parts) > 1:
        folders = parts[:-1] 
        for folder in reversed(folders):
            # If the folder name doesn't look like "Assignment_1", pick it!
            lower_name = folder.lower()
            if not any(bad in lower_name for bad in blacklist) and not re.search(r'\d{2}-\d{2}', folder):
                candidate_name = folder
                break
    
    # If Strategy 2 failed or found nothing, fallback to Filename
    if not candidate_name or strategy == "Folder Name Only":
        # If forced Folder but none found, warn user, else default to filename
        if strategy == "Folder Name Only" and len(parts) > 1:
            candidate_name = parts[-2]
        else:
            candidate_name = os.path.splitext(filename)[0]

    return candidate_name.replace("_", " ").title()

# --- 3. FORENSICS LOGIC ---
def get_file_hash(bytes_data):
    return hashlib.md5(bytes_data).hexdigest()

def get_image_histogram(image_bytes):
    try:
        file_bytes = np.asarray(bytearray(image_bytes.read()), dtype=np.uint8)
        image = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)
        hist = cv2.calcHist([image], [0, 1, 2], None, [8, 8, 8], [0, 256, 0, 256, 0, 256])
        cv2.normalize(hist, hist)
        return hist.flatten()
    except: return None

def extract_project_code(bytes_data):
    logic = []
    assets = set()
    sprites = 0
    try:
        with zipfile.ZipFile(bytes_data) as z:
            for f in z.namelist():
                if f != 'project.json':
                    assets.add(hashlib.md5(z.read(f)).hexdigest())
            if 'project.json' in z.namelist():
                project = json.loads(z.read('project.json'))
                targets = project.get('targets', [])
                sprites = len(targets)
                for t in targets:
                    for b in t.get('blocks', {}).values():
                        if isinstance(b, dict) and not b.get('shadow'):
                            logic.append(b.get('opcode', ''))
    except: return None, None, 0
    return "\n".join(logic), assets, sprites

# --- 4. SIDEBAR ---
with st.sidebar:
    st.title("üõ°Ô∏è Settings")
    
    st.markdown("### üè∑Ô∏è Name Detection")
    name_mode = st.radio(
        "How are files named?",
        ["Auto-Smart Detect", "Folder Name Only", "File Name Only"],
        help="If results show 'Assignment_1', switch to 'File Name Only'."
    )
    
    st.markdown("---")
    st.markdown("### üîç Sensitivity")
    code_thresh = st.slider("Code Match %", 70, 100, 90)
    
    if st.button("Clear Results"):
        st.session_state.log_history = []
        st.experimental_rerun()

# --- 5. MAIN APP ---
st.title("üõ°Ô∏è Little KITES Forensics (v9.0)")
st.caption("Developed by Midhun T V, Master Trainer, KITE Kasaragod")

uploaded_files = st.file_uploader("üìÇ Upload Class Zip or Files", type=["zip", "sb3", "p3b", "png", "jpg"], accept_multiple_files=True)

if uploaded_files:
    projects = {}
    images = {}
    
    with st.spinner("Analyzing..."):
        for up_file in uploaded_files:
            # --- ZIP HANDLING ---
            if up_file.name.endswith(".zip"):
                try:
                    with zipfile.ZipFile(up_file) as z:
                        for f_path in z.namelist():
                            if f_path.startswith("__") or f_path.endswith("/"): continue
                            
                            # === MAGIC NAME EXTRACTION ===
                            owner = clean_student_name(f_path, name_mode)
                            # Append original filename to avoid duplicates if same student has 2 files
                            raw_filename = os.path.basename(f_path)
                            unique_id = f"{owner} ({raw_filename})"
                            
                            ext = f_path.split('.')[-1].lower()
                            raw = io.BytesIO(z.read(f_path))
                            
                            if ext in ['sb3', 'p3b']:
                                l, a, s = extract_project_code(raw)
                                if l: projects[unique_id] = {'hash': get_file_hash(raw.getvalue()), 'logic': l, 'sprites': s, 'path': f_path}
                            
                            elif ext in ['jpg', 'png']:
                                h = get_image_histogram(raw)
                                if h is not None: 
                                    raw.seek(0)
                                    images[unique_id] = {'hist': h, 'obj': raw, 'path': f_path}
                except: st.error(f"Bad Zip: {up_file.name}")
            
            # --- SINGLE FILE HANDLING ---
            else:
                owner = os.path.splitext(up_file.name)[0]
                up_file.seek(0)
                ext = up_file.name.split('.')[-1].lower()
                if ext in ['sb3', 'p3b']:
                    l, a, s = extract_project_code(up_file)
                    if l: projects[owner] = {'hash': get_file_hash(up_file.getvalue()), 'logic': l, 'sprites': s, 'path': up_file.name}

    # --- RESULTS ---
    tab1, tab2, tab3 = st.tabs(["üß© Project Analysis", "üñºÔ∏è Poster Analysis", "üìÑ Report"])

    with tab1:
        if len(projects) < 2: st.info("Need 2+ projects.")
        else:
            pairs = list(combinations(projects.keys(), 2))
            found = False
            for p1, p2 in pairs:
                d1, d2 = projects[p1], projects[p2]
                
                # Logic Sim
                sim = difflib.SequenceMatcher(None, d1['logic'], d2['logic']).ratio() * 100
                is_binary = d1['hash'] == d2['hash']
                
                if sim > code_thresh:
                    found = True
                    match_type = "üö® EXACT COPY" if is_binary else f"‚ö†Ô∏è Logic Match ({sim:.1f}%)"
                    
                    st.markdown(f"""
                    <div class="report-card">
                        <h4>{match_type}</h4>
                        <span class="student-name">{p1}</span> <br>vs<br> <span class="student-name">{p2}</span>
                        <hr>
                        <div class="file-path">Original Path A: {d1['path']}</div>
                        <div class="file-path">Original Path B: {d2['path']}</div>
                    </div>""", unsafe_allow_html=True)
                    
                    st.session_state.log_history.append(f"[PROJECT] {p1} vs {p2} | {match_type}")

            if not found: st.markdown('<div class="success-box">‚úÖ No Cheating Detected</div>', unsafe_allow_html=True)

    with tab2:
        if len(images) < 2: st.info("Need 2+ images.")
        else:
            pairs = list(combinations(images.keys(), 2))
            found = False
            for p1, p2 in pairs:
                d1, d2 = images[p1], images[p2]
                sim = cv2.compareHist(d1['hist'], d2['hist'], cv2.HISTCMP_CORREL) * 100
                
                if sim > 85: # Fixed threshold for posters
                    found = True
                    st.markdown(f"""
                    <div class="report-card">
                        <h4>üé® Visual Match: {sim:.1f}%</h4>
                        <span class="student-name">{p1}</span> vs <span class="student-name">{p2}</span>
                    </div>""", unsafe_allow_html=True)
                    c1, c2 = st.columns(2)
                    c1.image(d1['obj'], caption=p1, width=200)
                    c2.image(d2['obj'], caption=p2, width=200)
                    st.session_state.log_history.append(f"[IMAGE] {p1} vs {p2} ({sim:.1f}%)")

            if not found: st.markdown('<div class="success-box">‚úÖ No Visual Cheating Detected</div>', unsafe_allow_html=True)

    with tab3:
        if st.session_state.log_history:
            txt = "\n".join(st.session_state.log_history)
            st.text_area("Log", txt)
            st.download_button("Download Report", txt, "report.txt")
